
 # 논리상으로는 되도록 쌩으로 쪼개서,
 제대로 돌린 것이 맞는 것 같은데..
 
 자꾸 5번째 바퀴에서 멈춘다.
 엔터를 치면
 5번째도 제대로 나오는데..
 
 혹은 디버깅모드로 돌리면 제대로 출력된다.
 
 ===
 
 단순화 시켜서 일단 배열에 할당만 한 상태를 
 
 Q4344_3에다 돌려보았다.
 
 breakPoint를 
 
 int[][] classScores = new int[C][];
 
 해당 부분에 놓고 돌렸더니 
 
 하단에 전체 for문을 돌려도 다 돌아간다.
 
 ===
 
 그렇다면 아마도..
 
 이차원 배열을 선언한 후, 
 
 int[][] classScores = new int[C][];
 
 하단에 다시 그 인자에다가 새로운 배열을 선언,
 
 classScores[i] = new int[innerArraySize];
 
 하는 형태에 문제가 있지 않을까 추정해본다.
 
 ===
 
 상단의 2차원 배열의 선언은 null로 초기화가 되는데..
 
 배열의 2번째 크기를 0,1로 해줬다가,
 
 다시 new로 내부를 생성해주면,
 
 같은 결과값이 나온다.
 
 ===
 
 잠시 이차원 배열의 선언 등에 대해서 검색중..
 
 ...
 
 흠 찾아보면 나와 같은 방법도 사용하는 방법이긴 한데..
 
 ...
 
 햐 희안하네..
 
 마지막 9개짜리의 순서를 다른데로 옮기면 다 된다..
 
 ===
 
 와, 하나하나 돌려보니까,
 
 int innerArraySize = sc.nextInt();
 
 이 부분에서 멈추네..
 
 ===
 
 일단 라인단위로 읽는 패턴으로 바꿔봐?
 
 뭐 이거 sc를 쓰면 안된는건가..
 
 line으로 하면 안되네..
 
 sc에 뭐 길이제한이라도 있는건가..
 
 ===
 
 검색을 통해서,
 
 scanner 인자 무한이 받기에 착안해서,
 
while(sc.hasNextLine()){
	System.out.println(sc.nextLine());
}    
sc.close();

 라는 것에 착안하여 for 문의 반복횟수를
 
for (int i = 0; sc.hasNextLine(); i++) {

 로 변경하니,
 
 다 받아진다.
 
 아닌데..
 
 ===
 
 buffer를 써야겠다..
 
 buffer를 사용해서,
 
 반복문으로 모두 출력되게는 완료.
 
 ===
 
 좀 짱나게 하네..
 
 걍 뭉탱이로 다 뽑아보자 buffer로
 
 ===
 
 흠..
 
 캐스팅하고, br, bw 사용해서,
 
 스트링으로 값 똑같이 구현해서
 
 제출했는데..
 
 왜 런타임에러나,
 
 틀렸습니다가 뜨는거지..
 
 런타임에러는 익셉션 때매 뜨는것 같고..
 
 뭐 스트링이 아니기라도 한거야?
 
 숫자 소수점 형태,
 
 decimal 사용 해봄.
 
 하면 .000이 안나오는데..
 
 0.000 패턴으로 표시되도, 틀린다.
 
 어차피 string으로 되는 것 같기도 한데..
 
 들여쓰기도 이것저것 해봤는데..
 
 뭐지?
 
 ===
 
 아 맞았다...
 
 이거 캐스팅해서 하는게 아니라,,
 
 숫자계산만 가지고 한 다음에,
 
 decimal 등 사용해서 반올림 계산 해주는 거구나..
 
 
 모르는 부분이 크니까 어림짐작으로 하려니까,
 
 좀 고생했다.
 
 이 문제 하나가지고,
 
 거의 4~5일을 시룬 것 같은데..
 
 뭐 그럴수도 있지,,
 
 여튼, 여러가지 교훈을 얻었다.
 
 교훈은 README.md 에다가나 적어야지
 
 === 
 
 
 
 
 
 