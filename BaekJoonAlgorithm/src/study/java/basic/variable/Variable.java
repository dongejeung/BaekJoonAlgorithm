package study.java.basic.variable;

public class Variable {
	/*
	 * 	변수 : 값을 저장할 수 있는 메모리상의 공간.
	 * 
	 * 	변수 선언 : 타입과 변수이름.
	 * 
	 * 	변수의 초기화(처음 값 저저아) : 변수 선언 + 	=(대입) 값
	 * 
	 * 	* 지역변수는 사용되기 전에 초기화를 반드시 해야 하지만,
	 * 	 클래스변수와 인스턴스변수는 초기화를 생략할 수 있다.
	 * 
	 *  =======
	 *  
	 *  # 변수의 명명 규칙
	 *  1. 대소문자 구분되며 길이에 제한이 없다.
	 *  2. 예약어를 사용해서는 안 된다.
	 *  3. 숫자로 시작해서는 안 된다.
	 *  4. 특수문자는 _ 와 $ 만 허용한다.
	 *  
	 *  + 권장 규칙
	 *  1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
	 *  2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
	 *  3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 _ 로 구분한다.
	 *  
	 *  =======
	 *  
	 *  # 변수의 타입
	 *  
	 *  1. 기본형 : 실제 값을 저장
	 *  - 논리형 : boolean(1byte) 
	 *  - 문자형 : char(2byte)
	 *  - 정수형 : byte, short(2byte), int(4byte), long(8byte)
	 *  - 실수형 : float(4byte), double(8byte)
	 *  
	 *  + byte 는 이진 데이터를 다룰 때 사용됨.
	 *  + short 은 C언어와의 호환을 위해서 추가되었다.
	 *  + int는 CPU가 가장 효율적으로 처리할 수 있는 타입
	 *  
	 *  2. 참조형 : 값이 저장되어 있는 주소를 값으로 갖는다.
	 *  - 8개의 기본형을 제외한 나머지 타입
	 *  
	 *  * 자바는 참조형 변수 간의 연산을 할 수 없으므로,
	 *   실제 연산에 사용되는 것은 모두 기본형 변수이다.
	 *	
	 *
	 *	+ new : 객체 생성 연산자
	 *	+ 참조형 변수는 null 또는 객체의 주소(4 byte, 0x0FFFFFFFF)를 값으로 갖는다.
	 *	(JVM 32 bit 가 아닌 64bit 라면 참조형 변수의 크기는 8 byte)
	 *
	 *	+ 저장 가능한 값의 범위는 참조.
	 *	(기본적으로는 -2^(n-1) ~ +2^(n-1)-1, n은 바이트 수) 
	 * 	
	 * 	+ 실수형은 정수형과 저장형식이 달라서 오차가 발생할 수 있다.
	 * 	=> 정밀도가 중요하다.
	 * 	float : 정밀도 7의 자리
	 * 	double : 정밀도 15 자리
	 *	
	 *	=======
	 *
	 * 	# 상수와 리터럴 	
	 * 
	 * 	1. 상수 : 변수선언시 앞에 final 키워드 붙여주면 됨.
	 * 	+ 상수는 선언과 동시에 초기화 해주어야 함.
	 * 	+ 상수는 snake case 가 관례 
	 * 	+ 상수는 리터럴에 의미있는 이름을 붙여서,
	 * 	 코드의 이해와 수정을 쉽게 만든다.
	 * 
	 * 	2. 리터럴 : 변수에 대입되는 값들.
	 * 	
	 * 	2-1. 리터럴의 타입과 접미사
	 * 		종류		리터럴							접미사
	 * 		논리형		false, true						없음
	 * 	 	정수형		123, 0b0101, 077, 0xFF, 100L	L
	 * 		실수형		3.14, 3.0e8, 1.4f, 0x1.0p-1		f, d
	 * 		문자형		'A', '1', '\n'					없음
	 * 		문자열		"ABC", "123", "A", "true"		없음
	 *
	 * 	3. 리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만,
	 *  타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.
	 *  
	 *  int i = 'A'			=> 유니코드로 저장
	 *  long l = 123;		=> 범위가 더 넓음
	 *  double d = 3.14f;	=> 범위가 더 넓음
	 *  
	 *  4. 형식화된 출력 printf()
	 *  System.out.printf("age:%d", age);
	 *  => %d 는 지시자로 값을 어떻게 출력할 것인지를 지정
	 *  
	 *  지시자
	 *  %b		=> 불린
	 *  %d		=> 10진수
	 *  %o		=> 8진수
	 *  %x, %X	=> 16진수
	 *  %f		=> 부동소수점
	 *  %e, %E	=> 지수 표현식의 형식
	 *  %c		=> 문자
	 *  %s		=> 문자열
	 *  			
	 *  이하 생략..
	 *  
	 *  5. 화면에서 입력받기 Scanner
	 *  
	 *  =======
	 *  
	 *  # 진법
	 *  
	 *  1. 2진수는 10진수를 온전히 표현 가능. 덧셈 뺄셈도 10진수와 동일
	 *  
	 *  비트 : 한 자리의 2진수 0 / 1
	 *  바이트 : 8 비트
	 *  ?)워드 : 4바이트(32비트 64비트 컴퓨터는 64비트)
	 *  => CPU 가 한 번에 처리할 수 있는 데이터의 크기!
	 *  
	 *  중간 생략..
	 *  
	 *  2진수, 8진수 16진수 변환
	 *  8진수 한 자리 = 2진수 3자리
	 *  16진수 한 자리 = 2진수 4자리
	 *  
	 *  
	 *  2. 정수의 진법 변환
	 *  - 10진수 다른 진수 변환 :
	 *  
	 *  해당 진수로 나누고 나머지 값을 옆에 적는 것을,
	 *   더 이상 나눌 수 없을 때까지 반복,
	 *   몫과 나머지를 아래부터 위로 순서대로 적으면 된다.
	 *  
	 *  - n 진수를 10진수로 변환
	 *  각 자리수 * 해당 단위의 값
	 *  
	 *  
	 *  3. 실수의 진법변환
	 *  
	 *  - 10진 소수점수를 2진 소수점수로 변환 :
	 *  
	 *  10진 소수점수에 2를 계속 곱한다.
	 *  
	 *  위의 결과에서 소수부만 가져다가 다시 2를 곱한다.
	 *  
	 *  소수부가 0이 될 때까지 반복한다.
	 *  
	 *  위의 결과에서 정수부만을 위에서 아래로 순서대로 적고 '0.' 을 앞에 붙이면 된다.
	 *  
	 *  cf) 소수부는 진수 * -n(자리수) 로 보면 될 것 같다.
	 *  
	 *  
	 *  4. 음수의 2진 표현 - 2의 보수법 cf) 표 참고.
	 *  
	 *  4-1. 첫 번째 비트는 부호 비트.
	 *  
	 *  4-2. 어떤 수의 'n의 보수'는 더했을 때 n이 되는 수를 말한다.
	 *  ex) 7의 10의 보수는 3 이다.
	 *  
	 *  4-3. 2진수로 '10'은 자리올림이 발생하고 0이 되는 수를 뜻한다.
	 *  
	 *  4-4. '2의 보수 관계'에 있는 두 2진수를 더하면 자리올림이 발생하고 0이 된다.
	 *  
	 *  4-5. 2의 보수 = 1의 보수 +1
	 *  
	 *  4-6. 1의 보수는 0을 1로 1을 0으로만 바꾸면 됨.
	 *  
	 *  4-7. +1 은 오버플로우를 이용해서 전체를 0으로 바꾼다.
	 *  
	 *	=======
	 *
	 *	# 기본형
	 *	
	 *	1. boolean : 자바의 최소 단위는 byte 이기 때문에, 1byte
	 *	, 자바는 대소문자를 구분하므로 TRUE 는 다름.
	 *
	 * 	2. char : 문자가 아닌 문자의 유니코드가 저장된다. (기본 2byte)
	 * 	ex) 'A' = 65	=> 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.
	 * 	cf) 아스키코드, 확장 아스키, 유니코드(uft-8, uft-16)
	 *	cf) (int)ch => 유니코드가 저장된다.
	 *
	 *	특수문자 : \n 역슬래시 사용. 엔터티 참조. p.57 (특수)문자 리터럴 참조.
	 *
	 *	cf) 음수가 없어서 unsigned
	 *	(어차피 컴퓨터는 최종적으로는 binary 로 저장.)
	 *	
	 *	! 값만으로는 알 수 없고, 값의 타입까지 알아야 올바르게 해석할 수 있다.
	 *
	 *	cf) 인코딩: 문자 => 코드
	 *		디코딩: 코드 => 문자
	 *  
	 *  => 인코딩시 적절한 코드표를 사용해야 함.
	 *  
	 *  utf-8 : 영어 1byte, 한글 3 byte.
	 *  utf-8 은 문자의 크기가 작지만, 가변적이므로 다루기 어렵다.
	 *  전송속도 때문에 uft-8 을 자주 씀
	 *  
	 *  =======
	 *  
	 *  # 정수형
	 *  
	 *  byte	short	int		long
	 *  1		2		4		8
	 *  
	 *  => 바이트 수를 통해 2^(n-1) 의 형태로 데이터의 범위 계산 가능.
	 *  
	 *  cf) int 가 가장 효율적인 타입이고, 
	 *  int => long => BigInteger
	 *  
	 *  ---
	 *  
	 *  오버플로우
	 *  
	 *  =======
	 *  
	 *  # 실수형 - float, double
	 *  
	 *  1. 오버플로우, 언더플로우 발생가능
	 *  - 오버플로우 : 변수의 값이 무한대? 가 된다고 함.
	 *  - 언더플로우 : 
	 *  
	 *  2. 실수형은 부호(S), 지수(E), 가수(M) 세 부분으로 이루어져 있다.
	 *  - 가수(+-M * 2^(E))
	 *  - float : 1, 8, 23
	 *  - double : 1, 11, 52
	 *  
	 *  3. 정밀도
	 *  - float : 7자리.
	 *  - double : 15자리.
	 *  
	 *  - 정밀도 때문에 double 을 많이 사용함.
	 *  - 연산속도의 향상이나 메모리 절약은 float 형.
	 *  
	 *  4. 실수형의 저장형식
	 *  - 부호 0 => 양수, 1 => 음수
	 *  - 2의 보수법을 사용하지 않는다.
	 *  - float 의 경우 -127(숫자아님), 128(양의 무한대) 표현을 위해 예약되어 있음.
	 *  - 가수인 M 은 실제 값. float 는 2진수 23자리, 10진수 7자리,
	 *   double 로는 2진수 52자리, 10진수 15자리 정도 저장 가능.
	 *   
	 *   - 부동소수점의 오차. 
	 *   => 실수 중에는 파이와 같은 무한소수가 존재하므로, 실수를 저장할 때는 오차가 발생할 수 있다.
	 *   ==>> 게다가 10진수가 아닌 2진수로 저장하기 때문에, 10진수로는 유한소수이더라도,
	 *    2진수로 변환하면 무한소수가 되는 경우도 있다. (2진수 표현의 한계)
	 *    
	 *   - 정규화 : 2진수로 변환도니 실수를 저장할 때는 먼저 '1.xxx * 2^(n)의 형태로 변환하는 것.
	 *   => 정규화된 2진 실수는 항상 '1.' 로 시작하기 때문에, '1.' 을 제외한 23자리의 2진수가 가수에 저장되고,
	 *    그 이후는 잘려나간다.
	 *    지수는 기저법으로 저장되기 때문에, 지수인 3에 기저인 127을 더한 130이 2진수로 변환되어 저장된다.
	 *    *cf) 기저법 : 저장할 때 특정값(기저)을 더했다가 읽어올 때는 다시 빼는 셈법.
	 *    
	 *    
	 *  
	 *  
	 */
}
