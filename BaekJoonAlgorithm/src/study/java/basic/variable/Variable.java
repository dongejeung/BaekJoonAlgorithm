package study.java.basic.variable;

public class Variable {
	/*
	 * 	변수 : 값을 저장할 수 있는 메모리상의 공간.
	 * 
	 * 	변수 선언 : 타입과 변수이름.
	 * 
	 * 	변수의 초기화(처음 값 저저아) : 변수 선언 + 	=(대입) 값
	 * 
	 * 	* 지역변수는 사용되기 전에 초기화를 반드시 해야 하지만,
	 * 	 클래스변수와 인스턴스변수는 초기화를 생략할 수 있다.
	 * 
	 *  =======
	 *  
	 *  # 변수의 명명 규칙
	 *  1. 대소문자 구분되며 길이에 제한이 없다.
	 *  2. 예약어를 사용해서는 안 된다.
	 *  3. 숫자로 시작해서는 안 된다.
	 *  4. 특수문자는 _ 와 $ 만 허용한다.
	 *  
	 *  + 권장 규칙
	 *  1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
	 *  2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
	 *  3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 _ 로 구분한다.
	 *  
	 *  =======
	 *  
	 *  # 변수의 타입
	 *  
	 *  1. 기본형 : 실제 값을 저장
	 *  - 논리형 : boolean(1byte) 
	 *  - 문자형 : char(2byte)
	 *  - 정수형 : byte, short(2byte), int(4byte), long(8byte)
	 *  - 실수형 : float(4byte), double(8byte)
	 *  
	 *  + byte 는 이진 데이터를 다룰 때 사용됨.
	 *  + short 은 C언어와의 호환을 위해서 추가되었다.
	 *  + int는 CPU가 가장 효율적으로 처리할 수 있는 타입
	 *  
	 *  2. 참조형 : 값이 저장되어 있는 주소를 값으로 갖는다.
	 *  - 8개의 기본형을 제외한 나머지 타입
	 *  
	 *  * 자바는 참조형 변수 간의 연산을 할 수 없으므로,
	 *   실제 연산에 사용되는 것은 모두 기본형 변수이다.
	 *	
	 *
	 *	+ new : 객체 생성 연산자
	 *	+ 참조형 변수는 null 또는 객체의 주소(4 byte, 0x0FFFFFFFF)를 값으로 갖는다.
	 *	(JVM 32 bit 가 아닌 64bit 라면 참조형 변수의 크기는 8 byte)
	 *
	 *	+ 저장 가능한 값의 범위는 참조.
	 *	(기본적으로는 -2^(n-1) ~ +2^(n-1)-1, n은 바이트 수) 
	 * 	
	 * 	+ 실수형은 정수형과 저장형식이 달라서 오차가 발생할 수 있다.
	 * 	=> 정밀도가 중요하다.
	 * 	float : 정밀도 7의 자리
	 * 	double : 정밀도 15 자리
	 *	
	 *	=======
	 *
	 * 	# 상수와 리터럴 	
	 * 
	 * 	1. 상수 : 변수선언시 앞에 final 키워드 붙여주면 됨.
	 * 	+ 상수는 선언과 동시에 초기화 해주어야 함.
	 * 	+ 상수는 snake case 가 관례 
	 * 	+ 상수는 리터럴에 의미있는 이름을 붙여서,
	 * 	 코드의 이해와 수정을 쉽게 만든다.
	 * 
	 * 	2. 리터럴 : 변수에 대입되는 값들.
	 * 	
	 * 	2-1. 리터럴의 타입과 접미사
	 * 		종류		리터럴							접미사
	 * 		논리형		false, true						없음
	 * 	 	정수형		123, 0b0101, 077, 0xFF, 100L	L
	 * 		실수형		3.14, 3.0e8, 1.4f, 0x1.0p-1		f, d
	 * 		문자형		'A', '1', '\n'					없음
	 * 		문자열		"ABC", "123", "A", "true"		없음
	 *
	 * 	3. 리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만,
	 *  타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.
	 *  
	 *  int i = 'A'			=> 유니코드로 저장
	 *  long l = 123;		=> 범위가 더 넓음
	 *  double d = 3.14f;	=> 범위가 더 넓음
	 *  
	 *  4. 형식화된 출력 printf()
	 *  System.out.printf("age:%d", age);
	 *  => %d 는 지시자로 값을 어떻게 출력할 것인지를 지정
	 *  
	 *  지시자
	 *  %b		=> 불린
	 *  %d		=> 10진수
	 *  %o		=> 8진수
	 *  %x, %X	=> 16진수
	 *  %f		=> 부동소수점
	 *  %e, %E	=> 지수 표현식의 형식
	 *  %c		=> 문자
	 *  %s		=> 문자열
	 *  			
	 *  이하 생략..
	 *  
	 *  5. 화면에서 입력받기 Scanner
	 *  
	 *  =======
	 *  
	 *  # 진법
	 *  
	 *  1. 2진수는 10진수를 온전히 표현 가능. 덧셈 뺄셈도 10진수와 동일
	 *  
	 *  비트 : 한 자리의 2진수 0 / 1
	 *  바이트 : 8 비트
	 *  ?)워드 : 4바이트(32비트 64비트 컴퓨터는 64비트)
	 *  => CPU 가 한 번에 처리할 수 있는 데이터의 크기!
	 *  
	 *  중간 생략..
	 *  
	 *  2진수, 8진수 16진수 변환
	 *  8진수 한 자리 = 2진수 3자리
	 *  16진수 한 자리 = 2진수 4자리
	 *  
	 *  
	 *  2. 정수의 진법 변환
	 *  - 10진수 다른 진수 변환 :
	 *  
	 *  해당 진수로 나누고 나머지 값을 옆에 적는 것을,
	 *   더 이상 나눌 수 없을 때까지 반복,
	 *   몫과 나머지를 아래부터 위로 순서대로 적으면 된다.
	 *  
	 *  - n 진수를 10진수로 변환
	 *  각 자리수 * 해당 단위의 값
	 *  
	 *  
	 *  3. 실수의 진법변환
	 *  
	 *  - 10진 소수점수를 2진 소수점수로 변환 :
	 *  
	 *  10진 소수점수에 2를 계속 곱한다.
	 *  
	 *  위의 결과에서 소수부만 가져다가 다시 2를 곱한다.
	 *  
	 *  소수부가 0이 될 때까지 반복한다.
	 *  
	 *  위의 결과에서 정수부만을 위에서 아래로 순서대로 적고 '0.' 을 앞에 붙이면 된다.
	 *  
	 *  cf) 소수부는 진수 * -n(자리수) 로 보면 될 것 같다.
	 *  
	 *  
	 *  4. 음수의 2진 표현 - 2의 보수법 cf) 표 참고.
	 *  
	 *  4-1. 첫 번째 비트는 부호 비트.
	 *  
	 *  4-2. 어떤 수의 'n의 보수'는 더했을 때 n이 되는 수를 말한다.
	 *  ex) 7의 10의 보수는 3 이다.
	 *  
	 *  4-3. 2진수로 '10'은 자리올림이 발생하고 0이 되는 수를 뜻한다.
	 *  
	 *  4-4. '2의 보수 관계'에 있는 두 2진수를 더하면 자리올림이 발생하고 0이 된다.
	 *  
	 *  4-5. 2의 보수 = 1의 보수 +1
	 *  
	 *  4-6. 1의 보수는 0을 1로 1을 0으로만 바꾸면 됨.
	 *  
	 *  4-7. +1 은 오버플로우를 이용해서 전체를 0으로 바꾼다.
	 *  
	 *	=======
	 *
	 *	# 기본형
	 *	
	 *	1. boolean : 자바의 최소 단위는 byte 이기 때문에, 1byte
	 *	, 자바는 대소문자를 구분하므로 TRUE 는 다름.
	 *
	 * 	2. char : 문자가 아닌 문자의 유니코드가 저장된다. (기본 2byte)
	 * 	ex) 'A' = 65	=> 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.
	 * 	cf) 아스키코드, 확장 아스키, 유니코드(uft-8, uft-16)
	 *	cf) (int)ch => 유니코드가 저장된다.
	 *
	 *	특수문자 : \n 역슬래시 사용. 엔터티 참조. p.57 (특수)문자 리터럴 참조.
	 *
	 *	cf) 음수가 없어서 unsigned
	 *	(어차피 컴퓨터는 최종적으로는 binary 로 저장.)
	 *	
	 *	! 값만으로는 알 수 없고, 값의 타입까지 알아야 올바르게 해석할 수 있다.
	 *
	 *	cf) 인코딩: 문자 => 코드
	 *		디코딩: 코드 => 문자
	 *  
	 *  => 인코딩시 적절한 코드표를 사용해야 함.
	 *  
	 *  utf-8 : 영어 1byte, 한글 3 byte.
	 *  utf-8 은 문자의 크기가 작지만, 가변적이므로 다루기 어렵다.
	 *  전송속도 때문에 uft-8 을 자주 씀
	 *  
	 *  =======
	 *  
	 *  # 정수형
	 *  
	 *  byte	short	int		long
	 *  1		2		4		8
	 *  
	 *  => 바이트 수를 통해 2^(n-1) 의 형태로 데이터의 범위 계산 가능.
	 *  
	 *  cf) int 가 가장 효율적인 타입이고, 
	 *  int => long => BigInteger
	 *  
	 *  ---
	 *  
	 *  오버플로우
	 *  
	 *  =======
	 *  
	 *  # 실수형 - float, double
	 *  
	 *  1. 오버플로우, 언더플로우 발생가능
	 *  - 오버플로우 : 변수의 값이 무한대? 가 된다고 함.
	 *  - 언더플로우 : 
	 *  
	 *  2. 실수형은 부호(S), 지수(E), 가수(M) 세 부분으로 이루어져 있다.
	 *  - 가수(+-M * 2^(E))
	 *  - float : 1, 8, 23
	 *  - double : 1, 11, 52
	 *  
	 *  3. 정밀도
	 *  - float : 7자리.
	 *  - double : 15자리.
	 *  
	 *  - 정밀도 때문에 double 을 많이 사용함.
	 *  - 연산속도의 향상이나 메모리 절약은 float 형.
	 *  
	 *  4. 실수형의 저장형식
	 *  - 부호 0 => 양수, 1 => 음수
	 *  - 2의 보수법을 사용하지 않는다.
	 *  - float 의 경우 -127(숫자아님), 128(양의 무한대) 표현을 위해 예약되어 있음.
	 *  - 가수인 M 은 실제 값. float 는 2진수 23자리, 10진수 7자리,
	 *   double 로는 2진수 52자리, 10진수 15자리 정도 저장 가능.
	 *   
	 *   - 부동소수점의 오차. 
	 *   => 실수 중에는 파이와 같은 무한소수가 존재하므로, 실수를 저장할 때는 오차가 발생할 수 있다.
	 *   ==>> 게다가 10진수가 아닌 2진수로 저장하기 때문에, 10진수로는 유한소수이더라도,
	 *    2진수로 변환하면 무한소수가 되는 경우도 있다. (2진수 표현의 한계)
	 *    
	 *   - 정규화 : 2진수로 변환도니 실수를 저장할 때는 먼저 '1.xxx * 2^(n)의 형태로 변환하는 것.
	 *   => 정규화된 2진 실수는 항상 '1.' 로 시작하기 때문에, '1.' 을 제외한 23자리의 2진수가 가수에 저장되고,
	 *    그 이후는 잘려나간다.
	 *    지수는 기저법으로 저장되기 때문에, 지수인 3에 기저인 127을 더한 130이 2진수로 변환되어 저장된다.
	 *    *cf) 기저법 : 저장할 때 특정값(기저)을 더했다가 읽어올 때는 다시 빼는 셈법.
	 *    
	 *    
	 *   =======
	 *   
	 *   # 형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
	 *   
	 *   (타입)피연산자
	 *   
	 *   
	 *   - 기본형에서 boolean 을 제외한 나머지 타입들은 서로 형변환이 가능하다.
	 *   - 기본형과 참조형간의 형변환은 불가능하다.
	 *   (뒷 장에서 나온다 함.)
	 *   
	 *   1. 정수형 간의 형 변화
	 *   - 더 작은 형으로 변환시 버림으로 처리. => 값 손실 가능.
	 *   - 더 큰 형으로 변환시 => 값 손실 없고, 빈 값 0으로 처리.
	 *   (음수의 경우 1로 채움. 부호 유지 위해.)
	 *   
	 *   2. 실수형 간의 형변환
	 *   2-1. 작은 타입 => 큰 타입
	 *   - 빈 공간을 0으로 채운다.
	 *   - 지수눈 float 의 기저인 127 을 뺀 후 double 의 기저인 1023을 더해서 변환하고,
	 *   - 가수는 float 의 가수 23자리를 채우고 남은 자리를 0으로 채운다.
	 *   
	 *   2-2. 큰 타입 => 작은 타입
	 *   - 지수는 double 의 기저인 1023을 뺀 후 float 의 기저인 127을 더하고,
	 *   - 가수는 double의 가수 52 자리 중 23 자리만 저장되고 나머지는 버려진다.
	 *   - 가수의 24번째 자리에서 반올림이 발생할 수 있다.
	 *   
	 *   3. float 타입의 범위를 넘는 값을 float 로 형변환하는 경우는 +-무한대 또는 +-0 이 나옴.
	 *   - 정밀도의 차이로 형 변환 하기전 값에 따라서 결과가 달라질 수 있음.
	 *   - 실수에는 무한대, 0 (+-) 을 표시하는 특수한 숫자가 있음.(범위의 끝)
	 *   
	 *   4. 정수형과 실수형 간의 형변환
	 *   
	 *   4-1. 정수형 => 실수형
	 *   - 정규화를 거쳐 저장. (값 손실 없음) ex) int => float case
	 *   - 정밀도에 의한 오차는 발생 가능.
	 *   - int 의 최대값은 20억으로 최대 10 자리의 정밀도를 요구.
	 *   => float 는 10진수로 약 7자리의 정밀도. 
	 *   => double 은 약 15자리의 정밀도.
	 *   
	 *   5. 실수형 => 정수형
	 *   - 실수형의 소수점이하 값은 버려진다.
	 *   
	 *   ---
	 *   
	 *   6. 자동 형변환
	 *   - 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 한다.
	 *   ex) float f = 1234;
	 *   
	 *   - 데이터 타입을 넘어가는 수를 담으려는 때(표현 가능한 범위를 넘어설 떄) 에러 발생.
	 *   byte b = 1000; (byte의 범위 -128 ~ 127)
	 *   => 이 때 명시적 형 벼환을 해주면 값 손실이 발생하고, 에러는 아니게 됨(프로그래머의 의도적 코딩으로 봄.)
	 *   
	 *   - 산술 변환 : 연산 과정에서 자동적으로 발생하는 형변환.
	 *   
	 *   - 표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로,
	 *    두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
	 *    
	 *   - 타입에 따른 데이터의 표현범위를 고려해서 생각해보면 어떤 일이 일어날 지 유추할 수 있다.
	 *   ...이하생략....
	 *   
	 *   =======
	 *   
	 *   # 연산자 : 연산을 수행하는 기호
	 *   
	 *   피연산자 : 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
	 *   
	 *   - 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환.
	 *   
	 *   - 식 : 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것.
	 *   - 식을 평가 : 식을 계산하여 결과를 얻는 것.
	 *   
	 *   ---
	 *   
	 *   2. 연산자의 종류
	 *   
	 *   산술 : + - * '/' % << >>
	 *   비교 : > < >= <= == !=
	 *   논리 : && || ! & | ^ ~		<= 이건 좀 헷갈리네.. 비트 연산이 있고.
	 *   대입 : =
	 *   기타 : ? : (삼항 연산자), (type) 형변환 연산자, instanceof(연산자)
	 *   
	 *   ---
	 *   
	 *   피 연산자의 개수를 통한 분류
	 *   - 단항 연산자
	 *   - 이항 연산자
	 *   - 삼항 연산자 (? : 하나뿐)
	 *   
	 *   ---
	 *   
	 *   3. 연산자의 우선순위와 결합규칙
	 *   - 대부분 왼쪽에서 오른쪽의 순서로 연산
	 *   - 단항 연산자와 대입 연산자만 오른쪽에서 왼쪽의 순서로, 연산을 수행.
	 *   
	 *   3-1. 산술 > 비교 > 논리 > 대입
	 *   3-2. 단항 > 이항 > 삼항 연산자
	 *   3-3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.
	 *   
	 *   우선순위 별 분류
	 *   1		++ -- + - ~ ! (type)
	 *   2		*, /, %
	 *   3		+, -
	 *   4		<<, >>
	 *   5		<, >, <=, >=, instanceof
	 *   6		==, !=
	 *   7		&
	 *   8		^
	 *   9		|
	 *   10		&&
	 *   11		||
	 *   12		?:
	 *   13		=, +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=
	 *   
	 *   (걍 헷갈리면 블록 처리 해버려!)
	 *   
	 *   ---
	 *   
	 *   4. 산술 변환
	 *   
	 *   : 두 피연산자의 타입이 다를 경우 => 더 큰 타입으로 오토 캐스팅.
	 *   
	 *   => int 보다 작은 형이면 int 형으로 오토 캐스팅.
	 *   
	 *   연산결과의 타입은 피연산자의 타입과 일치한다.
	 *   ex) int 5 / int 2 = 2 (소수점 버림.)
	 *   
	 *   ---
	 *   
	 *   5. 단항 연산자.
	 *   
	 *   : 전위 후위만 기억하면 된다.
	 *   
	 *   ---
	 *   
	 *   이하 생략..
	 *   
	 *   ---
	 *   
	 *   6. 산술 연산자.
	 *   
	 *   - 연산 우선순위 '*' '/' '%' > '+' '-'
	 *   - 피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다.
	 *   - 두 연산자 모두 타입이 같을 경우 결과의 범위를 넘어가면 버려짐.
	 *   - 부동소수점 0.0d(f) 로 나눌 경우 무한대가 됨. (p.98 참고)
	 *   
	 *   - 작은 변수 => 큰 자료형 ==>> 오토 캐스팅
	 *   - 큰 변수 => 작은 자료형 ==>> 캐스팅 없으면 에러. (혹은 틀린 값.)
	 *   
	 *   cf) int * int = int  => 값이 커져서 long 에다 담아도 int 로 계산된 결과(자리 버려짐)가 담긴다.
	 *   
	 *   cf) char 의 경우 아스키로 숫자로 변환되어 연산이 가능하다.
	 *   => 문자 '0' 이 시작점이라서 x - '0' 해주면 숫자로 변환된다.
	 *   
	 *   cf) 'a' + 1 은 리터럴 간의 연산이기 때문에,
	 *   컴파일러가 컴파일 시에 계산해서 그 결과를 대체한다.
	 *   ==>> 수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없기에 형 변환을 해주어야 한다.
	 *   
	 *   cf) 대소문자 차이는 십진수 32
	 *   
	 *   ---
	 *   
	 *   7. % 나머지 연산자
	 *   
	 *   - 피연산자로 정수만 허용한다.
	 *   - 음수도 허용하나 부호는 무시되고 절대값으로 나온다.
	 *   
	 *   ---
	 *   
	 *   8. 비교 연산자 : 결과가 boolean 리턴
	 *   - 이항 연산자이므로 두 피연산자의 타입을 같게 맞춘 다음 피연산자를 비교한다.
	 *   - 그러나 실수형의 경우 소수점 이하에서 오차가 발생할 수 있기 때문에 원하지 않는 결과가 나올 수 있다.
	 *   - double float 간의 비교는 float 로 변환한 다음에 비교해야 한다고 한다.
	 *   ex) 0.1f == 0.1(double) = false 다. 
	 *   - f 에 0.10000000149011612
	 *   - d 에 0.10000000000000001 로 저장된다.
	 *   
	 *   - 문자열의 비교는 .equals("") 로 한다.
	 *   == 은 값이(primitive) 같은지 비교 (문자열은 reference type 이다)
	 *   값을 비교하려면 .equals 를 사용해야 한다.
	 *   
	 *   cf) 스트링은 클래스지만 특별히 new 를 사용하지 않고 사용할 수 있게 예외로 해 줌.
	 *   
	 *   =======
	 *   
	 *   논리 연산자 : && || !
	 *   
	 *   =======
	 *   
	 *   비트 연산자 & | ^ << >>
	 *   
	 *   : 피연산자를 비트단위로 논리 연산.
	 *   
	 *   | (OR 연산자)	: 피연산자 중 한 쪽의 값이 1이면, 1을 결과로, 그 외에는 0을 얻는다.
	 *   & (AND 연산자)	: 피연산자 중 양 쪽의 값이 모두 1이어야만, 1을 결과로, 그 외에는 0을 얻는다.
	 *   ^ (XOR 연산자) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
	 *   (^ : eXclusive OR)
	 *   
	 *   | : 주로 특정 비트의 값을 변경할 때 사용한다.
	 *   
	 *   & : 주로 특정 비트의 값을 뽑아낼 때 사용한다.
	 *   
	 *   ^ : 같은 값으로 두고 ^ 연산을 수행하면 원래의 값으로 돌아오는 특징이 있어,
	 *   간단한 암호화에 사용한다.
	 *   
	 *   cf) 비트 연산은 type 의 자리수에 맞춰(2진으로) 계산되며,
	 *   타입을 일치시키는 '산술 변환'이 일어날 수 있다.
	 *   
	 *   ---
	 *   
	 *   ~ (비트 전환 연산자) : 0은 1로, 1은 0으로 바꾼다. (부호도 바뀜 => 1의 보수를 얻을 수 있음)
	 *   ex) p 에 대한 음의 정수 => '~p + 1'
	 *   ==>> 하지만 부호 연산자 '-' 를 사용하면 간단히 되므로 실제로 이렇게 쓸일은 잘 없음.
	 *   
	 *   << >> (쉬프트 연산자) : (2진수로 표현했을 때) 오른쪽 또는 왼쪽으로 비트 이동
	 *   => 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다.
	 *   cf) >> 연산자는 부호가 음수인 경우 빈자리를 1로 채움(음수 유지를 위해), 양수일 경우는 0으로 채운다.
	 *   cf) 쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int 보다 작은 타입은 int 타입으로 자동 변환,
	 *   되고 연산결과 역시 int 타입이 됨.
	 *   그러나 우측 피연산자는 타입을 일치시킬 필요가 없기 때문에 산술변환이 적용되지 않는다.
	 *   cf) << >> 은 '*2', '/2' 의 효과를 갖는다.
	 *   
	 *   !+ : 부울 대수로 사칙연산이 이루어지는 과정을 파악하려면, 어셈블리 언어를 보면 될 것 같다.
	 *   
	 *   cf) 쉬프트 연산자는 연산 속도가 빠름.
	 *   
	 *   !? 실수형 데이터를 비트연산 한다면?
	 *   => 부호 진수 가수부에 연산이 적용되고, 타입은 유지되나? 아님 에러?
	 *   ==>> 방금 테스트 해봤는데 에러가 난다.
	 *   
	 *   =======
	 *   
	 *   ? (조건(삼항) 연산자) : 조건식 ? 식1(true) : 식2(false)
	 *   => 중첩 가능하나, 가독성이 떨어짐.
	 *   
	 *   cf) 두 피연산자의 타입이 다른 경우, '산술 변환'이 발생.
	 *   
	 *   =======
	 *   
	 *   = (대입 연산자) : 우변의 값을 좌변으로. 연산자 우선순위 제일 낮음.
	 *   rvalue(우변값) => 식이나 상수 등 모두 가능.
	 *   lvalue(좌변값) => 반드시 변수처럼 값을 변경할 수 있는 것이어야 함. (리터럴, 상수 안됨)
	 *   
	 *   복합대입 연산자 : 연산자 + 대입연산자.
	 *   
	 *   =======
	 *   
	 *   # 조건문과 반복문(ch4)
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 */
}
