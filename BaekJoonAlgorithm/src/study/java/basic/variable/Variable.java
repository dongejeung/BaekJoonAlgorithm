package study.java.basic.variable;

public class Variable {
	/*
	 * 	변수 : 값을 저장할 수 있는 메모리상의 공간.
	 * 
	 * 	변수 선언 : 타입과 변수이름.
	 * 
	 * 	변수의 초기화(처음 값 저저아) : 변수 선언 + 	=(대입) 값
	 * 
	 * 	* 지역변수는 사용되기 전에 초기화를 반드시 해야 하지만,
	 * 	 클래스변수와 인스턴스변수는 초기화를 생략할 수 있다.
	 * 
	 *  =======
	 *  
	 *  # 변수의 명명 규칙
	 *  1. 대소문자 구분되며 길이에 제한이 없다.
	 *  2. 예약어를 사용해서는 안 된다.
	 *  3. 숫자로 시작해서는 안 된다.
	 *  4. 특수문자는 _ 와 $ 만 허용한다.
	 *  
	 *  + 권장 규칙
	 *  1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
	 *  2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
	 *  3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 _ 로 구분한다.
	 *  
	 *  =======
	 *  
	 *  # 변수의 타입
	 *  
	 *  1. 기본형 : 실제 값을 저장
	 *  - 논리형 : boolean(1byte) 
	 *  - 문자형 : char(2byte)
	 *  - 정수형 : byte, short(2byte), int(4byte), long(8byte)
	 *  - 실수형 : float(4byte), double(8byte)
	 *  
	 *  + byte 는 이진 데이터를 다룰 때 사용됨.
	 *  + short 은 C언어와의 호환을 위해서 추가되었다.
	 *  + int는 CPU가 가장 효율적으로 처리할 수 있는 타입
	 *  
	 *  2. 참조형 : 값이 저장되어 있는 주소를 값으로 갖는다.
	 *  - 8개의 기본형을 제외한 나머지 타입
	 *  
	 *  * 자바는 참조형 변수 간의 연산을 할 수 없으므로,
	 *   실제 연산에 사용되는 것은 모두 기본형 변수이다.
	 *	
	 *
	 *	+ new : 객체 생성 연산자
	 *	+ 참조형 변수는 null 또는 객체의 주소(4 byte, 0x0FFFFFFFF)를 값으로 갖는다.
	 *	(JVM 32 bit 가 아닌 64bit 라면 참조형 변수의 크기는 8 byte)
	 *
	 *	+ 저장 가능한 값의 범위는 참조.
	 *	(기본적으로는 -2^(n-1) ~ +2^(n-1)-1, n은 바이트 수) 
	 * 	
	 * 	+ 실수형은 정수형과 저장형식이 달라서 오차가 발생할 수 있다.
	 * 	=> 정밀도가 중요하다.
	 * 	float : 정밀도 7의 자리
	 * 	double : 정밀도 15 자리
	 *	
	 *	=======
	 *
	 * 	# 상수와 리터럴 	
	 * 
	 * 	1. 상수 : 변수선언시 앞에 final 키워드 붙여주면 됨.
	 * 	+ 상수는 선언과 동시에 초기화 해주어야 함.
	 * 	+ 상수는 snake case 가 관례 
	 * 	+ 상수는 리터럴에 의미있는 이름을 붙여서,
	 * 	 코드의 이해와 수정을 쉽게 만든다.
	 * 
	 * 	2. 리터럴 : 변수에 대입되는 값들.
	 * 	
	 * 	2-1. 리터럴의 타입과 접미사
	 * 		종류		리터럴							접미사
	 * 		논리형		false, true						없음
	 * 	 	정수형		123, 0b0101, 077, 0xFF, 100L	L
	 * 		실수형		3.14, 3.0e8, 1.4f, 0x1.0p-1		f, d
	 * 		문자형		'A', '1', '\n'					없음
	 * 		문자열		"ABC", "123", "A", "true"		없음
	 *
	 * 	3. 리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만,
	 *  타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.
	 *  
	 *  int i = 'A'			=> 유니코드로 저장
	 *  long l = 123;		=> 범위가 더 넓음
	 *  double d = 3.14f;	=> 범위가 더 넓음
	 *  
	 *  4. 형식화된 출력 printf()
	 *  System.out.printf("age:%d", age);
	 *  => %d 는 지시자로 값을 어떻게 출력할 것인지를 지정
	 *  
	 *  지시자
	 *  %b		=> 불린
	 *  %d		=> 10진수
	 *  %o		=> 8진수
	 *  %x, %X	=> 16진수
	 *  %f		=> 부동소수점
	 *  %e, %E	=> 지수 표현식의 형식
	 *  %c		=> 문자
	 *  %s		=> 문자열
	 *  			
	 *  이하 생략..
	 *  
	 *  5. 화면에서 입력받기 Scanner
	 *  
	 *  =======
	 *  
	 *  # 진법
	 *  
	 *  1. 2진수는 10진수를 온전히 표현 가능. 덧셈 뺄셈도 10진수와 동일
	 *  
	 *  비트 : 한 자리의 2진수 0 / 1
	 *  바이트 : 8 비트
	 *  ?)워드 : 4바이트(32비트 64비트 컴퓨터는 64비트)
	 *  => CPU 가 한 번에 처리할 수 있는 데이터의 크기!
	 *  
	 *  중간 생략..
	 *  
	 *  2진수, 8진수 16진수 변환
	 *  8진수 한 자리 = 2진수 3자리
	 *  16진수 한 자리 = 2진수 4자리
	 *  
	 *  
	 *  2. 정수의 진법 변환
	 *  - 10진수 다른 진수 변환 :
	 *  
	 *  해당 진수로 나누고 나머지 값을 옆에 적는 것을,
	 *   더 이상 나눌 수 없을 때까지 반복,
	 *   몫과 나머지를 아래부터 위로 순서대로 적으면 된다.
	 *  
	 *  - n 진수를 10진수로 변환
	 *  각 자리수 * 해당 단위의 값
	 *  
	 *  
	 *  3. 실수의 진법변환
	 *  
	 *  - 10진 소수점수를 2진 소수점수로 변환 :
	 *  
	 *  10진 소수점수에 2를 계속 곱한다.
	 *  
	 *  위의 결과에서 소수부만 가져다가 다시 2를 곱한다.
	 *  
	 *  소수부가 0이 될 때까지 반복한다.
	 *  
	 *  위의 결과에서 정수부만을 위에서 아래로 순서대로 적고 '0.' 을 앞에 붙이면 된다.
	 *  
	 *  cf) 소수부는 진수 * -n(자리수) 로 보면 될 것 같다.
	 *  
	 *  
	 *  4. 음수의 2진 표현 - 2의 보수법 cf) 표 참고.
	 *  
	 *  4-1. 첫 번째 비트는 부호 비트.
	 *  
	 *  4-2. 어떤 수의 'n의 보수'는 더했을 때 n이 되는 수를 말한다.
	 *  ex) 7의 10의 보수는 3 이다.
	 *  
	 *  4-3. 2진수로 '10'은 자리올림이 발생하고 0이 되는 수를 뜻한다.
	 *  
	 *  4-4. '2의 보수 관계'에 있는 두 2진수를 더하면 자리올림이 발생하고 0이 된다.
	 *  
	 *  4-5. 2의 보수 = 1의 보수 +1
	 *  
	 *  4-6. 1의 보수는 0을 1로 1을 0으로만 바꾸면 됨.
	 *  
	 *  4-7. +1 은 오버플로우를 이용해서 전체를 0으로 바꾼다.
	 *  
	 *	=======
	 *
	 *	# 기본형
	 *	
	 *	1. boolean : 자바의 최소 단위는 byte 이기 때문에, 1byte
	 *	, 자바는 대소문자를 구분하므로 TRUE 는 다름.
	 *
	 * 	2. char : 문자가 아닌 문자의 유니코드가 저장된다. (기본 2byte)
	 * 	ex) 'A' = 65	=> 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.
	 * 	cf) 아스키코드, 확장 아스키, 유니코드(uft-8, uft-16)
	 *	cf) (int)ch => 유니코드가 저장된다.
	 *
	 *	특수문자 : \n 역슬래시 사용. 엔터티 참조. p.57 (특수)문자 리터럴 참조.
	 *
	 *	cf) 음수가 없어서 unsigned
	 *	(어차피 컴퓨터는 최종적으로는 binary 로 저장.)
	 *	
	 *	! 값만으로는 알 수 없고, 값의 타입까지 알아야 올바르게 해석할 수 있다.
	 *
	 *	cf) 인코딩: 문자 => 코드
	 *		디코딩: 코드 => 문자
	 *  
	 *  => 인코딩시 적절한 코드표를 사용해야 함.
	 *  
	 *  utf-8 : 영어 1byte, 한글 3 byte.
	 *  utf-8 은 문자의 크기가 작지만, 가변적이므로 다루기 어렵다.
	 *  전송속도 때문에 uft-8 을 자주 씀
	 *  
	 *  =======
	 *  
	 *  # 정수형
	 *  
	 *  byte	short	int		long
	 *  1		2		4		8
	 *  
	 *  => 바이트 수를 통해 2^(n-1) 의 형태로 데이터의 범위 계산 가능.
	 *  
	 *  cf) int 가 가장 효율적인 타입이고, 
	 *  int => long => BigInteger
	 *  
	 *  ---
	 *  
	 *  오버플로우
	 *  
	 *  =======
	 *  
	 *  # 실수형 - float, double
	 *  
	 *  1. 오버플로우, 언더플로우 발생가능
	 *  - 오버플로우 : 변수의 값이 무한대? 가 된다고 함.
	 *  - 언더플로우 : 
	 *  
	 *  2. 실수형은 부호(S), 지수(E), 가수(M) 세 부분으로 이루어져 있다.
	 *  - 가수(+-M * 2^(E))
	 *  - float : 1, 8, 23
	 *  - double : 1, 11, 52
	 *  
	 *  3. 정밀도
	 *  - float : 7자리.
	 *  - double : 15자리.
	 *  
	 *  - 정밀도 때문에 double 을 많이 사용함.
	 *  - 연산속도의 향상이나 메모리 절약은 float 형.
	 *  
	 *  4. 실수형의 저장형식
	 *  - 부호 0 => 양수, 1 => 음수
	 *  - 2의 보수법을 사용하지 않는다.
	 *  - float 의 경우 -127(숫자아님), 128(양의 무한대) 표현을 위해 예약되어 있음.
	 *  - 가수인 M 은 실제 값. float 는 2진수 23자리, 10진수 7자리,
	 *   double 로는 2진수 52자리, 10진수 15자리 정도 저장 가능.
	 *   
	 *   - 부동소수점의 오차. 
	 *   => 실수 중에는 파이와 같은 무한소수가 존재하므로, 실수를 저장할 때는 오차가 발생할 수 있다.
	 *   ==>> 게다가 10진수가 아닌 2진수로 저장하기 때문에, 10진수로는 유한소수이더라도,
	 *    2진수로 변환하면 무한소수가 되는 경우도 있다. (2진수 표현의 한계)
	 *    
	 *   - 정규화 : 2진수로 변환도니 실수를 저장할 때는 먼저 '1.xxx * 2^(n)의 형태로 변환하는 것.
	 *   => 정규화된 2진 실수는 항상 '1.' 로 시작하기 때문에, '1.' 을 제외한 23자리의 2진수가 가수에 저장되고,
	 *    그 이후는 잘려나간다.
	 *    지수는 기저법으로 저장되기 때문에, 지수인 3에 기저인 127을 더한 130이 2진수로 변환되어 저장된다.
	 *    *cf) 기저법 : 저장할 때 특정값(기저)을 더했다가 읽어올 때는 다시 빼는 셈법.
	 *    
	 *    
	 *   =======
	 *   
	 *   # 형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
	 *   
	 *   (타입)피연산자
	 *   
	 *   
	 *   - 기본형에서 boolean 을 제외한 나머지 타입들은 서로 형변환이 가능하다.
	 *   - 기본형과 참조형간의 형변환은 불가능하다.
	 *   (뒷 장에서 나온다 함.)
	 *   
	 *   1. 정수형 간의 형 변화
	 *   - 더 작은 형으로 변환시 버림으로 처리. => 값 손실 가능.
	 *   - 더 큰 형으로 변환시 => 값 손실 없고, 빈 값 0으로 처리.
	 *   (음수의 경우 1로 채움. 부호 유지 위해.)
	 *   
	 *   2. 실수형 간의 형변환
	 *   2-1. 작은 타입 => 큰 타입
	 *   - 빈 공간을 0으로 채운다.
	 *   - 지수눈 float 의 기저인 127 을 뺀 후 double 의 기저인 1023을 더해서 변환하고,
	 *   - 가수는 float 의 가수 23자리를 채우고 남은 자리를 0으로 채운다.
	 *   
	 *   2-2. 큰 타입 => 작은 타입
	 *   - 지수는 double 의 기저인 1023을 뺀 후 float 의 기저인 127을 더하고,
	 *   - 가수는 double의 가수 52 자리 중 23 자리만 저장되고 나머지는 버려진다.
	 *   - 가수의 24번째 자리에서 반올림이 발생할 수 있다.
	 *   
	 *   3. float 타입의 범위를 넘는 값을 float 로 형변환하는 경우는 +-무한대 또는 +-0 이 나옴.
	 *   - 정밀도의 차이로 형 변환 하기전 값에 따라서 결과가 달라질 수 있음.
	 *   - 실수에는 무한대, 0 (+-) 을 표시하는 특수한 숫자가 있음.(범위의 끝)
	 *   
	 *   4. 정수형과 실수형 간의 형변환
	 *   
	 *   4-1. 정수형 => 실수형
	 *   - 정규화를 거쳐 저장. (값 손실 없음) ex) int => float case
	 *   - 정밀도에 의한 오차는 발생 가능.
	 *   - int 의 최대값은 20억으로 최대 10 자리의 정밀도를 요구.
	 *   => float 는 10진수로 약 7자리의 정밀도. 
	 *   => double 은 약 15자리의 정밀도.
	 *   
	 *   5. 실수형 => 정수형
	 *   - 실수형의 소수점이하 값은 버려진다.
	 *   
	 *   ---
	 *   
	 *   6. 자동 형변환
	 *   - 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 한다.
	 *   ex) float f = 1234;
	 *   
	 *   - 데이터 타입을 넘어가는 수를 담으려는 때(표현 가능한 범위를 넘어설 떄) 에러 발생.
	 *   byte b = 1000; (byte의 범위 -128 ~ 127)
	 *   => 이 때 명시적 형 벼환을 해주면 값 손실이 발생하고, 에러는 아니게 됨(프로그래머의 의도적 코딩으로 봄.)
	 *   
	 *   - 산술 변환 : 연산 과정에서 자동적으로 발생하는 형변환.
	 *   
	 *   - 표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로,
	 *    두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
	 *    
	 *   - 타입에 따른 데이터의 표현범위를 고려해서 생각해보면 어떤 일이 일어날 지 유추할 수 있다.
	 *   ...이하생략....
	 *   
	 *   =======
	 *   
	 *   # 연산자 : 연산을 수행하는 기호
	 *   
	 *   피연산자 : 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
	 *   
	 *   - 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환.
	 *   
	 *   - 식 : 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것.
	 *   - 식을 평가 : 식을 계산하여 결과를 얻는 것.
	 *   
	 *   ---
	 *   
	 *   2. 연산자의 종류
	 *   
	 *   산술 : + - * '/' % << >>
	 *   비교 : > < >= <= == !=
	 *   논리 : && || ! & | ^ ~		<= 이건 좀 헷갈리네.. 비트 연산이 있고.
	 *   대입 : =
	 *   기타 : ? : (삼항 연산자), (type) 형변환 연산자, instanceof(연산자)
	 *   
	 *   ---
	 *   
	 *   피 연산자의 개수를 통한 분류
	 *   - 단항 연산자
	 *   - 이항 연산자
	 *   - 삼항 연산자 (? : 하나뿐)
	 *   
	 *   ---
	 *   
	 *   3. 연산자의 우선순위와 결합규칙
	 *   - 대부분 왼쪽에서 오른쪽의 순서로 연산
	 *   - 단항 연산자와 대입 연산자만 오른쪽에서 왼쪽의 순서로, 연산을 수행.
	 *   
	 *   3-1. 산술 > 비교 > 논리 > 대입
	 *   3-2. 단항 > 이항 > 삼항 연산자
	 *   3-3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.
	 *   
	 *   우선순위 별 분류
	 *   1		++ -- + - ~ ! (type)
	 *   2		*, /, %
	 *   3		+, -
	 *   4		<<, >>
	 *   5		<, >, <=, >=, instanceof
	 *   6		==, !=
	 *   7		&
	 *   8		^
	 *   9		|
	 *   10		&&
	 *   11		||
	 *   12		?:
	 *   13		=, +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=
	 *   
	 *   (걍 헷갈리면 블록 처리 해버려!)
	 *   
	 *   
	 *   
	 *   
	 *   
	 *   
	 */
}
